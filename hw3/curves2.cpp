#include "WorkingScene.h"

// This file includes the basic functions that your program must fill in.  
// Your assignment consists of filling in parts that say /* YOUR CODE HERE */

// What happens when you drag the mouse to x and y?  
// In essence, you are dragging control points on the curve.
void WorkingScene::drag(int x, int y) {
  /* YOUR CODE HERE */
  //you must figure out how to transform x and y so they make sense
  //update oldx, and oldy
  //make sure scene gets redrawn
}

// Mouse motion.  You need to respond to left clicks (to add points on curve) 
// and right clicks (to delete points on curve) 
void WorkingScene::mouse(int button, int state, int x, int y) {
  if (theOnlyCurve && state == GLUT_DOWN) {
    if (button == GLUT_LEFT_BUTTON) {
      /* YOUR CODE HERE */
    }
    if (button == GLUT_RIGHT_BUTTON) {	
      /* YOUR CODE HERE */
    }
  }

  /* YOUR CODE HERE */
  //update oldx, and oldy
  //make sure scene gets redrawn
}



#include "Bezier.h"

// Bezier drawing function.  This is by deCasteljau or equivalent algorithm. 
// It should support Bezier curves of arbitrary degree/order.
void Bezier::draw(int levelOfDetail) {

  connectTheDots();
  int i,j,k;
  Pvector::iterator p;

  /* YOUR CODE HERE */
}



#include "Bspline.h"

// The B-Spline drawing routine.  
// Remember to call drawSegment (auxiliary function) for each set of 4 points.
void Bspline::draw(int levelOfDetail) {


  connectTheDots();
  /* YOUR CODE HERE */
}

void Bspline::drawSegment(Pvector::iterator p1, Pvector::iterator p2, 
    Pvector::iterator p3, Pvector::iterator p4, int levelOfDetail) {

  float x, y;
  /* YOUR CODE HERE */

  //draw segment

  //then create a Point to be drawn where the knot should be

  Point p(x, y);
  p.draw();
}

#include "Bezier2.h"

//This function is provided to aid you.
//It should be used in the spirit of recursion, though you may choose not to.
//This function takes an empty vector of points, accum
//It also takes a set of control points, pts, and fills accum with
//the control points that correspond to the next level of detail.
void accumulateNextLevel(Pvector* accum, Pvector pts) {
  if (pts.empty()) return; 
  accum->push_back(*(pts.begin()));
  if (pts.size() == 1) return;
  for (Pvector::iterator it = pts.begin(); it != pts.end() - 1; it++) {
    /* YOUR CODE HERE  (only one to three lines)*/
  }
  //save the last point
  Point last = *(pts.end()-1);
  pts.pop_back();
  //recursive call
  accumulateNextLevel(accum, pts);
  accum->push_back(last);
}


// The basic draw function for Bezier2.  Note that as opposed to Bezier, 
// this draws the curve by recursive subdivision.  So, levelofdetail 
// corresponds to how many times to recurse.  
void Bezier2::draw(int levelOfDetail) {
  //This is just a trick to find out if this is the top level call
  //All recursive calls will be given a negative integer, to be flipped here
  if (levelOfDetail > 0) {
    connectTheDots();
  } else {
    levelOfDetail = -levelOfDetail;
  }

  //Base case.  No more recursive calls.
  if (levelOfDetail <= 1) {
    if (points.size() >= 2) {
      for (Pvector::iterator it = points.begin(); it != points.end() - 1; it++) {

        /* YOUR CODE HERE */

      }
    }
  } else {
    Pvector* accum = new Pvector();
    Bezier2 left, right;

    //add the correct points to 'left' and 'right'.
    //You may or may not use accum as you see fit.
    /* YOUR CODE HERE */

    left.draw(1-levelOfDetail);
    right.draw(1-levelOfDetail);
    delete accum;
  }
}
